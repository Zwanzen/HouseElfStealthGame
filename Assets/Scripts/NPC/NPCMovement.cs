using System;
using System.Collections;
using Pathfinding;
using UnityEngine;
using static RigidbodyMovement;

public class NPCMovement
{
    // Initialize variables
    private NPC _npc;
    private Seeker _seeker;
    
    private float _maxRecalcPathTime; // Max time to recalculate path
    private readonly float _lookAhead; // Used to look ahead in the seeker path
    private LayerMask _groundLayers; // Used to check if the npc is on the ground
    private float _springStrength = 10f; // Spring strength for the rigidbody
    private float _springDampener = 0.5f; // Spring dampener for the rigidbody
    private float _rotationSpeed;
    
    // Constructor
    public NPCMovement(NPC npc,float maxRecalcPathTime, float lookAhead, LayerMask groundLayers, float springStrength, float springDampener, float rotationSpeed)
    {
        _npc = npc;
        _seeker = npc.GetComponent<Seeker>();
        _maxRecalcPathTime = maxRecalcPathTime;
        _lookAhead = lookAhead;
        _stopPosition = _npc.Rigidbody.position;
        _groundLayers = groundLayers;
        _springStrength = springStrength;
        _springDampener = springDampener;
        _rotationSpeed = rotationSpeed;
    }
    
    private enum TargetType
    {
        None,
        Path,
        Position
    }
    // ___ Pathing ___
    private TargetType _targetType;
    private NPCPath _targetNPCPath; // Used if we are moving on a path
    private int _targetNPCPathIndex = -1;
    private int _npcPathDirection = 1; // Used to move up or down the path
    private Path _seekerPath; // Used to store the path generated by the seeker
    private int _seekerPathIndex = -1;
    private Vector3 _targetPosition;
    private bool _calcNewPathPoint = false;
    private Vector3 _stopPosition;
    private bool _isStopped;
    private float _stopTimer = 0f;
    private float _recalculatePathTimer = 0f;
    
    // ___ Rotation ___
    private Vector3 _targetPathRotation;
    private Vector3 _dirToRotate;
    
    // ___ Anim ___
    private bool _readyForAnimChange = false;
    
    // Events
    public Action ArrivedAtTarget;
    public Action<NPCAnimator.AnimState> OnAnimStateChange;

    #region Pathing
    // Used by NPC to set either a path or a single point
    public void SetTarget(NPCPath npcPath)
    {
        ClearTargets();
        _targetNPCPath = npcPath;
        FindClosestNPCPoint(npcPath);
    }
    public void SetTarget(Vector3 position)
    {
        ClearTargets();
        _targetPosition = position;
        FindPathToTargetPosition(_targetPosition);
    }
    
    // Stop Movement
    public void Stop()
    {
        ClearTargets();
    }
    
    // Used to clear current target, stopping movement
    private void ClearTargets()
    {
        _readyForAnimChange = true;
        _targetType = TargetType.None;
        _targetNPCPath = null;
        _targetNPCPathIndex = -1;
        _seekerPath = null;
        _seekerPathIndex = -1;
        _stopPosition = _npc.Rigidbody.position;
        _isStopped = false;
        _calcNewPathPoint = false;
        _npc.StopAllCoroutines();
        _seeker.CancelCurrentPathRequest();
        _targetNPCPath = null;
        OnAnimStateChange(NPCAnimator.AnimState.Idle);
    }

    private void FindClosestNPCPoint(NPCPath npcPath)
    {
        // If the path is not valid, return zero
        if(npcPath.Waypoints.Length == 0)
            return;
        
        // We go through all the waypoints and use seeker to find the closest one
        _seeker.StartMultiTargetPath(_npc.transform.position, npcPath.Positions,true, OnClosestPathFound);
    }
    
    private void OnClosestPathFound(Path p)
    {
        // We need to go through NPC path to find what index the closest point is
        if (p.error)
        {
            Debug.LogError("Error finding closest point: " + p.errorLog);
            return;
        }
        
        // We now go through every position and find the closest one
        var pathEnd = p.vectorPath[^1];
        var closestDist = 0f;
        var closestIndex = -1;
        for (int i = 0; i < _targetNPCPath.Positions.Length; i++)
        {
            if(closestIndex == -1)
            {
                closestIndex = i;
                closestDist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
            }
            else
            {
                var dist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
                if (dist < closestDist)
                {
                    closestIndex = i;
                    closestDist = dist;
                }
            }
        }
        
        // If the _targetNPCPathIndex is -1, we couldn't find the closest point
        if (closestIndex == -1)
        {
            Debug.LogError("Closest point not found in NPC path");
            return;
        }
        
        // We set the _targetNPCPathIndex to the closest index
        _targetNPCPathIndex = closestIndex;
        FindPathToPathPoint();
    }

    private void FindPathToTargetPosition(Vector3 pos)
    {
        _seeker.StartPath(_npc.transform.position, pos, OnTargetPositionPathFound);
    }
    
    private void OnTargetPositionPathFound(Path p)
    {
        // We need to check if the path is valid
        if (p.error)
        {
            Debug.LogError("Error finding path to target position: " + p.errorLog);
            return;
        }
        
        // We set the seekerPath to the path found
        _seekerPath = p;
        // We set the seekerPathIndex to 0
        _seekerPathIndex = 0;
        // We now set target type
        _targetType = TargetType.Position;
        OnAnimStateChange(NPCAnimator.AnimState.Walk);
    }

    private void FindPathToPathPoint(bool forcePath = false)
    {
        // If we are calculating new path point, and is not forcePath, we need to return
        if (_calcNewPathPoint && !forcePath)
            return;

        _seeker.StartPath(_npc.transform.position, _targetNPCPath.Positions[_targetNPCPathIndex], OnPathToPathPointFound);
    }
    
    private void OnPathToPathPointFound(Path p)
    {
        // If we are calculating a new path point, we need to set the _calcNewPathPoint to false
        if (_calcNewPathPoint)
        {
            _calcNewPathPoint = false;
        }
        
        // We need to check if the path is valid
        if (p.error)
        {
            Debug.LogError("Error finding path to path point: " + p.errorLog);
            return;
        }
        
        // We set the seekerPath to the path found
        _seekerPath = p;
        // We set the seekerPathIndex to 0
        _seekerPathIndex = 0;
        // We now set target type
        _targetType = TargetType.Path;
        OnAnimStateChange(NPCAnimator.AnimState.Walk);
    }

    private void NextPathPoint()
    {
        if (!_targetNPCPath.IsLoop)
        {
            // We need to check if we are at the end of the path
            if (_targetNPCPathIndex + _npcPathDirection >= _targetNPCPath.Waypoints.Length)
            {
                _npcPathDirection = -1;
            }
            else if (_targetNPCPathIndex + _npcPathDirection < 0)
            {
                _npcPathDirection = 1;
            }
            
            // We set the target index to the next point
            _targetNPCPathIndex += _npcPathDirection;
        }
        else
        {
            // If we are out of loop, we need set the _targetNPCPathIndex to 0
            if (_targetNPCPathIndex + _npcPathDirection >= _targetNPCPath.Waypoints.Length)
            {
                _targetNPCPathIndex = 0;
            }
            else
            {
                _targetNPCPathIndex++;
            }
        }
        
        _calcNewPathPoint = true;
        FindPathToPathPoint(true);
    }
    
    private void UpdateSeekerPath()
    {
        // Only update seeker path if we have a path
        if (_seekerPath == null)
            return;
        
        // Check in a loop if we are close enough to the current waypoint to switch to the next one.
        // We do this in a loop because many waypoints might be close to each other and we may reach
        // several of them in the same frame.
        var reachedEndOfPath = false;
        // The distance to the next waypoint in the path
        float distanceToWaypoint;
        while (true) {
            // If you want maximum performance you can check the squared distance instead to get rid of a
            // square root calculation. But that is outside the scope of this tutorial.
            distanceToWaypoint = Vector3.Distance(_npc.transform.position, _seekerPath.vectorPath[_seekerPathIndex]);
            if (distanceToWaypoint < _lookAhead) {
                // Check if there is another waypoint or if we have reached the end of the path
                if (_seekerPathIndex + 1 < _seekerPath.vectorPath.Count) {
                    _seekerPathIndex++;
                    _stopPosition = _seekerPath.vectorPath[_seekerPathIndex];
                } else {
                    reachedEndOfPath = true;
                    break;
                }
            } else {
                break;
            }
        }

        if (reachedEndOfPath)
        {
            if (_targetType == TargetType.Path)
            {
                // Wait until we are not stopped
                if(_isStopped)
                    return;
                
                var wp = _targetNPCPath.Waypoints[_targetNPCPathIndex];
                // We need to check if the npc path point is a stop point
                if (wp.HasStop)
                {
                    // We need to register stop
                    _isStopped = true;
                    // We need to set stop position to the last point
                    _stopPosition = _seekerPath.vectorPath[^1];
                    // We also need to set the stop timer to the stop time
                    _stopTimer = wp.StopTime;
                }
                else
                {
                    // We need to go to the next point
                    NextPathPoint();
                }
            }
            else
            {
                // We set the stop position to the last point
                _stopPosition = _seekerPath.vectorPath[^1];
                ClearTargets();
                
                // Call the arrived at target event after clear
                ArrivedAtTarget.Invoke();
            }
            _recalculatePathTimer = 0f;
            _readyForAnimChange = true;
                
        }
        
    }
    
    private void RecalculateMove(float delta)
    {
        _recalculatePathTimer += delta;
        if(_recalculatePathTimer < _maxRecalcPathTime || _isStopped)
            return;
        
        _recalculatePathTimer = 0f;

        // We need to recalculate path sometimes
        // This is done to avoid the path being blocked by something
        if (_targetType == TargetType.Path)
        {
            // If we are calculating new path point, and is not forcePath, we need to return
            if (_calcNewPathPoint)
                return;

            _seeker.StartPath(_npc.transform.position, _targetNPCPath.Positions[_targetNPCPathIndex], OnRecalculatedPath);
        }
        else if (_targetType == TargetType.Position)
        {
            _seeker.StartPath(_npc.transform.position, _targetPosition, OnTargetPositionPathFound);
        }
    }
    
    private void OnRecalculatedPath(Path p)
    {
        // We need to check if the path is valid
        if (p.error)
        {
            Debug.LogError("Error finding path: " + p.errorLog);
            return;
        }
        
        // We set the seekerPath to the path found
        _seekerPath = p;
        // We set the seekerPathIndex to 0
        _seekerPathIndex = 0;
    }
    
    private void Move(Rigidbody rb, Vector3 position, MovementSettings settings)
    {
        MoveToRigidbody(rb, position, settings);
    }
    
    private void HandleMovement(float delta)
    {
        RecalculateMove(delta);
        UpdateSeekerPath();
        
        if (_targetType == TargetType.None)
        {
            // Make sure the the y position is the same as the npc
            _stopPosition.y = _npc.Rigidbody.position.y;
            MoveToRigidbody(_npc.Rigidbody,_stopPosition, _npc.MovementSettings);
        }
        else
        {
            // Now the seekerPath is valid, we need to check if we are close to the next point
            var nextPoint = _seekerPath.vectorPath[_seekerPathIndex];
            var adjustedPos = new Vector3(nextPoint.x, _npc.Rigidbody.position.y, nextPoint.z);
            Move(_npc.Rigidbody, adjustedPos, _npc.MovementSettings);
        }

        if (_isStopped)
        {
            // We need to check if we are close enough to the stop position
            _stopPosition.y = _npc.Rigidbody.position.y;
            var distanceToStop = Vector3.Distance(_npc.Rigidbody.position, _stopPosition);
            // If we are not close enough, we dont do anything
            if (distanceToStop > 0.1f)
                return;
            // If we are not rotated correctly, we dont do anything
            if (_dirToRotate != Vector3.zero)
            {
                var angle = Vector3.SignedAngle(_npc.Rigidbody.transform.forward, _dirToRotate, Vector3.up);
                if (Mathf.Abs(angle) > 1f)
                    return;
            }
            
            // now we check if we should update animation to idle
            if (_readyForAnimChange)
            {
                _readyForAnimChange = false;
                OnAnimStateChange(NPCAnimator.AnimState.Idle);
            }
            
            _stopTimer -= delta;
            if (_stopTimer <= 0f)
            {
                _isStopped = false;
                _stopTimer = 0f;
                // We need to go to the next point
                NextPathPoint();
            }
        }
        
    }
    
    #endregion

    #region Movement

    private void HandleRotation(float delta)
    {
        // We set the rotation if we are moving
        if (_targetType != TargetType.None && !_isStopped)
        {
            var dir = _stopPosition - _npc.Rigidbody.position;
            dir.y = 0f;
            dir.Normalize();
            _dirToRotate = dir;
        }

        if (_targetType == TargetType.Path)
        {
            // If we are stopped, and close enough to the stop position
            // we set the dirToRotate to waypoint direction if it has any
            var wp = _targetNPCPath.Waypoints[_targetNPCPathIndex];
            var distanceToStop = Vector3.Distance(_npc.Rigidbody.position, _stopPosition);
            if (_isStopped && distanceToStop < 0.1f && wp.HasDirection)
                _dirToRotate = wp.Direction;
        }
        
        // Rotate towards the direction we are moving
        if (_dirToRotate != Vector3.zero)
        {
            RotateRigidbody(_npc.Rigidbody, _dirToRotate, _rotationSpeed);
        }
    }

        // Credit: https://youtu.be/qdskE8PJy6Q?si=hSfY9B58DNkoP-Yl
    // Modified
    public void RigidbodyFloat()
    {
        var height = 1.8f;
        var heightOffset = Vector3.up * height;
        var radius = 0.3f;

        if(!Physics.SphereCast(_npc.Rigidbody .position + heightOffset, radius, Vector3.down, out var hit, Mathf.Infinity, _groundLayers))
            return;
        
        var vel = _npc.Rigidbody.linearVelocity;

        var relDirVel = Vector3.Dot(Vector3.down, vel);

        var relVel = relDirVel;

        var x = hit.distance - height + radius/2f;
        
        var springForce = (x * _springStrength) - (relVel * _springDampener);
        _npc.Rigidbody.AddForce(Vector3.down * springForce);
    }
    
    #endregion
    public void FixedUpdate(float delta)
    {
        HandleMovement(delta);
        HandleRotation(delta);
        RigidbodyFloat();
    }

    
}