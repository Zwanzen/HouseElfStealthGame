using System;
using Pathfinding;
using UnityEngine;
using static RigidbodyMovement;

public class NPCMovement : MonoBehaviour
{
    private NPC _npc;
    private Seeker _seeker;
    private const float DistanceThreshold = 0.1f;
    private enum TargetType
    {
        Path,
        Position
    }
    private TargetType _targetType;
    private NPCPath _targetNPCPath; // Used if we are moving on a path
    private int _targetNPCPathIndex = -1;
    private Vector3 _targetPosition; // Used if we are only moving to a single point
    private Path _seekerPath; // Used to store the path generated by the seeker
    private int _seekerPathIndex = -1;
    
    // Events
    private Action _arrivedAtPoint;
    private Action _arrivedAtPathPoint;
    private Action _pathCompleted;
    
    // Used by NPC to set either a path or a single point
    public void SetTarget(NPCPath npcPath)
    {
        ClearTargets();
        _targetNPCPath = npcPath;
        _targetType = TargetType.Path;
        FindClosestNPCPoint(npcPath);
    }
    public void SetTarget(Vector3 position)
    {
        ClearTargets();
        _targetPosition = position;
        _targetType = TargetType.Position;
    }
    
    // Used to clear current target, stopping movement
    private void ClearTargets()
    {
        _targetNPCPath = null;
        _targetNPCPathIndex = -1;
        _targetPosition = Vector3.zero;
        _seekerPath = null;
        _seekerPathIndex = -1;
    }

    private void FindClosestNPCPoint(NPCPath npcPath)
    {
        // If the path is not valid, return zero
        if(npcPath.Waypoints.Length == 0)
            return;
        
        // We go through all the waypoints and use seeker to find the closest one
        _seeker.StartMultiTargetPath(transform.position, npcPath.Positions,true, OnClosestPathFound);
    }
    
    private void OnClosestPathFound(Path p)
    {
        // We need to go through NPC path to find what index the closest point is
        if (p.error)
        {
            Debug.LogError("Error finding closest point: " + p.errorLog);
            return;
        }
        
        // We now go through every position and find the closest one
        var pathEnd = p.vectorPath[^1];
        var closestDist = 0f;
        var closestIndex = -1;
        for (int i = 0; i < _targetNPCPath.Positions.Length; i++)
        {
            if(closestIndex == -1)
            {
                closestIndex = i;
                closestDist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
            }
            else
            {
                var dist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
                if (dist < closestDist)
                {
                    closestIndex = i;
                    closestDist = dist;
                }
            }
        }
        
        // If the _targetNPCPathIndex is -1, we couldn't find the closest point
        if (closestIndex == -1)
        {
            Debug.LogError("Closest point not found in NPC path");
            return;
        }
        
        // We set the _targetNPCPathIndex to the closest index
        _targetNPCPathIndex = closestIndex;
    }

    // Updates target
    private void UpdateTarget()
    {
            
    }
    
    // Get seeker path
    private void Seek()
    {
        
    }
    
    // Updates seeker path
    private void UpdateSeekerPath()
    {
        if(_seekerPath == null)
            return;
        if (_seekerPathIndex == -1)
            return;
        
        
    }

    private void Awake()
    {
        _npc = GetComponent<NPC>();
        _seeker = GetComponent<Seeker>();
    }

    private void FixedUpdate()
    {
        HandleMovement();
    }

    private void HandleMovement()
    {
        if(_targetNPCPathIndex != -1)
            Debug.DrawLine(transform.position, _targetNPCPath.Positions[_targetNPCPathIndex], Color.red);
    }
    
    private void MoveToMovement(Rigidbody rb, Vector3 position, MovementSettings settings)
    {
        MoveToRigidbody(rb, position, settings);
        if (Vector3.Distance(rb.position, position) < DistanceThreshold)
        {
            _arrivedAtPoint.Invoke();
        }
    }


}