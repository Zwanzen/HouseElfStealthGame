using System;
using Pathfinding;
using UnityEngine;
using static RigidbodyMovement;

public class NPCMovement
{
    // Initialize variables
    private NPC _npc;
    private Seeker _seeker;
    
    private float _lookAhead; // Used to look ahead in the seeker path
    
    // Constructor
    public NPCMovement(NPC npc, float lookAhead)
    {
        _npc = npc;
        _seeker = npc.GetComponent<Seeker>();
        _lookAhead = lookAhead;
    }
    
    private const float DistanceThreshold = 0.2f;
    private enum TargetType
    {
        None,
        Path,
        Position
    }
    private TargetType _targetType;
    private NPCPath _targetNPCPath; // Used if we are moving on a path
    private int _targetNPCPathIndex = -1;
    private int _npcPathDirection = 1; // Used to move up or down the path
    private Path _seekerPath; // Used to store the path generated by the seeker
    private int _seekerPathIndex = -1;
    private Vector3 _targetPosition;
    
    // Events
    private Action _arrivedAtPoint;
    private Action _arrivedAtPathPoint;
    private Action _pathCompleted;

    // Used by NPC to set either a path or a single point
    public void SetTarget(NPCPath npcPath)
    {
        ClearTargets();
        _targetNPCPath = npcPath;
        FindClosestNPCPoint(npcPath);
    }
    public void SetTarget(Vector3 position)
    {
        ClearTargets();
        _targetPosition = position;
        FindPathToTargetPosition(_targetPosition);
    }
    
    // Used to clear current target, stopping movement
    private void ClearTargets()
    {
        _targetType = TargetType.None;
        _targetNPCPath = null;
        _targetNPCPathIndex = -1;
        _seekerPath = null;
        _seekerPathIndex = -1;
    }

    private void FindClosestNPCPoint(NPCPath npcPath)
    {
        // If the path is not valid, return zero
        if(npcPath.Waypoints.Length == 0)
            return;
        
        // We go through all the waypoints and use seeker to find the closest one
        _seeker.StartMultiTargetPath(_npc.transform.position, npcPath.Positions,true, OnClosestPathFound);
    }
    
    private void OnClosestPathFound(Path p)
    {
        // We need to go through NPC path to find what index the closest point is
        if (p.error)
        {
            Debug.LogError("Error finding closest point: " + p.errorLog);
            return;
        }
        
        // We now go through every position and find the closest one
        var pathEnd = p.vectorPath[^1];
        var closestDist = 0f;
        var closestIndex = -1;
        for (int i = 0; i < _targetNPCPath.Positions.Length; i++)
        {
            if(closestIndex == -1)
            {
                closestIndex = i;
                closestDist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
            }
            else
            {
                var dist = Vector3.Distance(pathEnd, _targetNPCPath.Positions[i]);
                if (dist < closestDist)
                {
                    closestIndex = i;
                    closestDist = dist;
                }
            }
        }
        
        // If the _targetNPCPathIndex is -1, we couldn't find the closest point
        if (closestIndex == -1)
        {
            Debug.LogError("Closest point not found in NPC path");
            return;
        }
        
        // We set the _targetNPCPathIndex to the closest index
        _targetNPCPathIndex = closestIndex;
        FindPathToPathPoint();
    }

    private void FindPathToTargetPosition(Vector3 pos)
    {
        _seeker.StartPath(_npc.transform.position, pos, OnTargetPositionPathFound);
    }
    
    private void OnTargetPositionPathFound(Path p)
    {
        // We need to check if the path is valid
        if (p.error)
        {
            Debug.LogError("Error finding path to target position: " + p.errorLog);
            return;
        }
        
        // We set the seekerPath to the path found
        _seekerPath = p;
        // We set the seekerPathIndex to 0
        _seekerPathIndex = 0;
        // We now set target type
        _targetType = TargetType.Position;
    }

    private void FindPathToPathPoint()
    {
        _seeker.StartPath(_npc.transform.position, _targetNPCPath.Positions[_targetNPCPathIndex], OnPathToPathPointFound);
    }
    
    private void OnPathToPathPointFound(Path p)
    {
        // We need to check if the path is valid
        if (p.error)
        {
            Debug.LogError("Error finding path to path point: " + p.errorLog);
            return;
        }
        
        // We set the seekerPath to the path found
        _seekerPath = p;
        // We set the seekerPathIndex to 0
        _seekerPathIndex = 0;
        // We now set target type
        _targetType = TargetType.Path;
        UpdateSeekerPath();
    }

    private void NextPathPoint()
    {
        if (!_targetNPCPath.IsLoop)
        {
            // We need to check if we are at the end of the path
            if (_targetNPCPathIndex + _npcPathDirection >= _targetNPCPath.Waypoints.Length)
            {
                _npcPathDirection = -1;
            }
            else if (_targetNPCPathIndex + _npcPathDirection < 0)
            {
                _npcPathDirection = 1;
            }
            
            // We set the target index to the next point
            _targetNPCPathIndex += _npcPathDirection;
        }
        else
        {
            // If we are out of loop, we need set the _targetNPCPathIndex to 0
            if (_targetNPCPathIndex + _npcPathDirection >= _targetNPCPath.Waypoints.Length)
            {
                _targetNPCPathIndex = 0;
            }
            else
            {
                _targetNPCPathIndex++;
            }
        }
        
        FindPathToPathPoint();
    }
    
    // Updates seeker path
    private void UpdateSeekerPath()
    {
        // Check in a loop if we are close enough to the current waypoint to switch to the next one.
        // We do this in a loop because many waypoints might be close to each other and we may reach
        // several of them in the same frame.
        var reachedEndOfPath = false;
        // The distance to the next waypoint in the path
        float distanceToWaypoint;
        while (true) {
            // If you want maximum performance you can check the squared distance instead to get rid of a
            // square root calculation. But that is outside the scope of this tutorial.
            distanceToWaypoint = Vector3.Distance(_npc.transform.position, _seekerPath.vectorPath[_seekerPathIndex]);
            if (distanceToWaypoint < _lookAhead) {
                // Check if there is another waypoint or if we have reached the end of the path
                if (_seekerPathIndex + 1 < _seekerPath.vectorPath.Count) {
                    _seekerPathIndex++;
                } else {
                    reachedEndOfPath = true;
                    break;
                }
            } else {
                break;
            }
        }

        if (reachedEndOfPath)
        {
            if (_targetType == TargetType.Path)
            {
                NextPathPoint();
            }
            else
            {
                ClearTargets();
            }
        }
    }

    public void HandleMovement()
    {

        if(_targetType == TargetType.None)
            return;

        // Now the seekerPath is valid, we need to check if we are close to the next point
        var nextPoint = _seekerPath.vectorPath[_seekerPathIndex];
        var adjustedPos = new Vector3(nextPoint.x, _npc.transform.position.y, nextPoint.z);
        Move(_npc.Rigidbody, adjustedPos, _npc.MovementSettings);
    }
    
    private float _recalculatePathTimer = 0f;
    public void Update(float delta)
    {
        // We need to recalculate path sometimes
        // This is done to avoid the path being blocked by something
        _recalculatePathTimer += delta;
        
        if (_recalculatePathTimer >= 0.2f)
        {
            _recalculatePathTimer = 0f;
            if (_targetType == TargetType.Path)
            {
                FindPathToPathPoint();
            }
            else if (_targetType == TargetType.Position)
            {
                FindPathToTargetPosition(_targetPosition);
            }
        }
    }
    
    private void Move(Rigidbody rb, Vector3 position, MovementSettings settings)
    {
        MoveToRigidbody(rb, position, settings);

        UpdateSeekerPath();
    }


}