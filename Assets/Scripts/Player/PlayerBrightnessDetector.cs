using UnityEngine;
using System.Collections.Generic;
using UnityEngine.UI;

// Generated by Gemini

/// <summary>
/// Detects brightness by sampling points on a sphere around a target transform,
/// checking line of sight against specified lights. Updates calculation periodically for efficiency.
/// Includes Editor/Play Mode visualizations. Uses an AnimationCurve for precise range falloff control.
/// Applies an exponent to visibility factor for adjustable obstruction response.
/// Smoothly updates an optional UI Slider.
/// </summary>
public class PlayerBrightnessDetector : MonoBehaviour
{
    // --- Constants ---
    private const float VISIBILITY_DOT_THRESHOLD = -0.1f;
    private const int MIN_SPHERE_RESOLUTION = 4;
    private const int MAX_SPHERE_RESOLUTION = 64;
    private const float GIZMO_POINT_SIZE = 0.015f;
    private const float MIN_UPDATE_INTERVAL = 0.016f; // Approx 60 FPS limit
    private const float MAX_UPDATE_INTERVAL = 1.0f;   // Max 1 sec interval

    // --- Inspector Variables ---
    [Header("Visibility UI")]
    [SerializeField] private Image visibilityImage; // UI Image to show visibility level
    [SerializeField] private Sprite[] visibilitySprites; // Array of 4 sprites (0 = hidden, 3 = fully visible)

    [Header("Core Settings")]
    [Tooltip("Center of the detection sphere. Uses this GameObject if null.")]
    [SerializeField] private Transform detectionCenterTransform;
    [Tooltip("Lights to check against.")]
    [SerializeField] private List<Light> targetLights = new List<Light>();
    [Tooltip("Layers that can block light.")]
    [SerializeField] private LayerMask obstructionLayers;
    [Tooltip("Final brightness multiplier.")]
    [Range(0f, 5f)]
    [SerializeField] private float lightIntensityMultiplier = 1f;

    [Header("Falloff & Visibility Control")] // Renamed Header
    [Tooltip("Controls light intensity based on distance. X-axis: Normalized Distance (0=center, 1=max range). Y-axis: Intensity Multiplier (0-1). Affects Point/Spot lights.")]
    [SerializeField]
    private AnimationCurve rangeFalloffCurve = new AnimationCurve(
        new Keyframe(0f, 1f),
        new Keyframe(0.8f, 1f),
        new Keyframe(1f, 0f)
    );
    [Tooltip("Exponent applied to the visibility factor. >1 means partial obstruction dims more significantly. 1 = linear.")]
    [Range(1f, 5f)] // Exponent >= 1
    [SerializeField] private float visibilityExponent = 1.5f; // <<< ADDED VISIBILITY EXPONENT

    [Header("Performance")]
    [Tooltip("How often (in seconds) to recalculate the brightness.")]
    [Range(MIN_UPDATE_INTERVAL, MAX_UPDATE_INTERVAL)]
    [SerializeField] private float updateInterval = 0.1f;

    [Header("Sphere Sampling Settings")]
    [Tooltip("Radius of the detection sphere.")]
    [Range(0.1f, 2.0f)]
    [SerializeField] private float detectionSphereRadius = 0.5f;
    [Tooltip("Density of sample points (Points = Res*Res).")]
    [Range(MIN_SPHERE_RESOLUTION, MAX_SPHERE_RESOLUTION)]
    [SerializeField] private int sphereResolution = 16;

    [Header("Debugging & UI")]
    [Tooltip("How quickly the UI slider interpolates to the target brightness.")]
    [Range(1f, 20f)]
    [SerializeField] private float sliderLerpSpeed = 8f;
    [Tooltip("Show sphere points Gizmo in Scene view.")]
    [SerializeField] private bool visualizeSphere = true;
    [Tooltip("Show visibility lines in Play Mode (only updates with calculation interval).")]
    [SerializeField] private bool visualizeLines = false;

    // --- Private State ---
    private float _currentBrightness = 0f;
    private List<Vector3> _relativeSpherePoints = new List<Vector3>();
    private float _previousRadius;
    private int _previousResolution;
    private bool _needsPointRegeneration = true;
    private float _timeSinceLastUpdate = 0f;

    // --- Properties ---
    public float CurrentBrightness => _currentBrightness;

    // --- Unity Methods ---
    void OnValidate()
    {
        detectionSphereRadius = Mathf.Clamp(detectionSphereRadius, 0.1f, 2.0f);
        sphereResolution = Mathf.Clamp(sphereResolution, MIN_SPHERE_RESOLUTION, MAX_SPHERE_RESOLUTION);
        updateInterval = Mathf.Clamp(updateInterval, MIN_UPDATE_INTERVAL, MAX_UPDATE_INTERVAL);
        sliderLerpSpeed = Mathf.Max(1f, sliderLerpSpeed);
        visibilityExponent = Mathf.Max(1f, visibilityExponent); // Ensure exponent is >= 1

        if (detectionSphereRadius != _previousRadius || sphereResolution != _previousResolution)
        {
            _needsPointRegeneration = true;
        }
        if (rangeFalloffCurve == null || rangeFalloffCurve.length == 0)
        {
            rangeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(0.8f, 1f), new Keyframe(1f, 0f));
        }
    }

    void Awake()
    {
        if (detectionCenterTransform == null)
        {
            Debug.LogWarning($"PlayerBrightnessDetector on {gameObject.name}: No Detection Center Transform assigned. Using this object's transform.", this);
        }
        EnsureSpherePointsGenerated();
        _timeSinceLastUpdate = updateInterval;
    }

    void Update()
    {
        _timeSinceLastUpdate += Time.deltaTime;

        if (_timeSinceLastUpdate >= updateInterval)
        {
            _timeSinceLastUpdate -= updateInterval;

#if UNITY_EDITOR
            EnsureSpherePointsGenerated();
#endif

            Vector3 center = GetDetectionCenter();
            if (center != Vector3.positiveInfinity)
            {
                _currentBrightness = CalculateTotalBrightness(center);
            }
            else
            {
                _currentBrightness = 0f;
            }

            if (Application.isPlaying && visualizeLines && center != Vector3.positiveInfinity)
            {
                DrawPlayModeDebugLines(center);
            }
        }
        UpdateVisibilityUI();
    }

    private void UpdateVisibilityUI()
    {
        if (visibilityImage == null || visibilitySprites == null || visibilitySprites.Length == 0)
            return;

        // Map brightness (0-1) to an index
        int index = Mathf.Clamp(Mathf.FloorToInt(_currentBrightness * (visibilitySprites.Length - 0.01f)), 0, visibilitySprites.Length - 1);
        if (index == 0 && CurrentBrightness >= 0.05)
            index = 1;
        visibilityImage.sprite = visibilitySprites[index];
    }

    // --- Core Logic ---
    private void EnsureSpherePointsGenerated()
    {
        if (_needsPointRegeneration || (_relativeSpherePoints.Count == 0 && sphereResolution > 0))
        {
            GenerateRelativeSpherePoints();
            _previousRadius = detectionSphereRadius;
            _previousResolution = sphereResolution;
        }
    }

    private float CalculateTotalBrightness(Vector3 center)
    {
        // (Calculation logic remains the same)
        if (targetLights == null || targetLights.Count == 0) return 0f;
        if (_relativeSpherePoints.Count == 0) return 0f;

        float totalBrightness = 0f;
        foreach (Light lightSource in targetLights)
        {
            if (lightSource == null || !lightSource.enabled || !lightSource.gameObject.activeInHierarchy || lightSource.intensity <= 0) continue;
            totalBrightness += ProcessLightSource(lightSource, center);
        }
        return Mathf.Clamp01(totalBrightness * lightIntensityMultiplier);
    }

    private float ProcessLightSource(Light light, Vector3 center)
    {
        Vector3 lightPos = light.transform.position;
        Vector3 dirToLight = (light.type == LightType.Directional) ? -light.transform.forward : (lightPos - center).normalized;
        float dist = (light.type == LightType.Directional) ? float.PositiveInfinity : Vector3.Distance(center, lightPos);

        float intensity = GetRawIntensityAtPoint(light, dist, dirToLight);
        if (intensity <= 0) return 0f;

        float visibilityFactor = (light.type == LightType.Directional) ? 1.0f : CalculateVisibilityFactor(light, center, dirToLight);

        // --- Apply Exponent to Visibility Factor ---
        // Ensure factor is non-negative before applying power
        float nonNegativeVisibility = Mathf.Max(0f, visibilityFactor);
        float adjustedVisibilityFactor = Mathf.Pow(nonNegativeVisibility, visibilityExponent);
        // --- End Apply Exponent ---

        // Use the adjusted factor
        return intensity * adjustedVisibilityFactor;
    }

    private float GetRawIntensityAtPoint(Light light, float distance, Vector3 directionToLight)
    {
        // (This function remains the same as the AnimationCurve version)
        float intensity = light.intensity;
        float range = light.range;

        if ((light.type == LightType.Point || light.type == LightType.Spot))
        {
            if (distance >= range || range <= 0f) return 0f;
            float normalizedDistance = Mathf.Clamp01(distance / range);
            float curveMultiplier = rangeFalloffCurve.Evaluate(normalizedDistance);
            intensity *= curveMultiplier;
            if (intensity <= 0f) return 0f;
        }

        if (light.type == LightType.Spot)
        {
            float angle = Vector3.Angle(-directionToLight, light.transform.forward);
            float halfAngle = light.spotAngle * 0.5f;
            if (angle <= halfAngle)
            {
                float spotAngleFalloff = Mathf.Clamp01(1.0f - (angle / halfAngle));
                intensity *= spotAngleFalloff * spotAngleFalloff;
            }
            else { return 0f; }
        }
        if (light.type == LightType.Directional) { }

        return intensity;
    }


    private float CalculateVisibilityFactor(Light light, Vector3 center, Vector3 directionToLight)
    {
        // (Calculation logic remains the same)
        if (_relativeSpherePoints.Count == 0) return 0f;
        int visiblePointCount = 0;
        Vector3 lightPos = light.transform.position;
        foreach (Vector3 relPoint in _relativeSpherePoints)
        {
            Vector3 worldPoint = center + relPoint;
            if (Vector3.Dot(relPoint.normalized, directionToLight) > VISIBILITY_DOT_THRESHOLD)
            {
                bool isVisible = !Application.isPlaying || !Physics.Linecast(worldPoint, lightPos, obstructionLayers);
                if (isVisible) { visiblePointCount++; }
            }
        }
        // Return raw visibility factor (0-1)
        return (_relativeSpherePoints.Count > 0) ? (float)visiblePointCount / _relativeSpherePoints.Count : 0f;
    }

    void GenerateRelativeSpherePoints()
    {
        // (Generation code remains the same)
        if (_relativeSpherePoints == null) _relativeSpherePoints = new List<Vector3>();
        _relativeSpherePoints.Clear();
        int currentResolution = Mathf.Clamp(sphereResolution, MIN_SPHERE_RESOLUTION, MAX_SPHERE_RESOLUTION);
        int numPoints = currentResolution * currentResolution;
        if (numPoints <= 0) return;
        float phi = Mathf.PI * (3f - Mathf.Sqrt(5f));
        float currentRadius = Mathf.Max(0.01f, detectionSphereRadius);
        for (int i = 0; i < numPoints; i++)
        {
            float y = 1 - (i / (float)(numPoints - 1)) * 2;
            float radiusAtY = Mathf.Sqrt(Mathf.Max(0f, 1f - y * y));
            float theta = phi * i;
            float x = Mathf.Cos(theta) * radiusAtY;
            float z = Mathf.Sin(theta) * radiusAtY;
            _relativeSpherePoints.Add(new Vector3(x, y, z) * currentRadius);
        }
        _needsPointRegeneration = false;
    }

    private Vector3 GetDetectionCenter()
    {
        // (Remains the same)
        if (detectionCenterTransform != null) return detectionCenterTransform.position;
        if (this.transform != null) return this.transform.position;
        return Vector3.positiveInfinity;
    }

    private void DrawPlayModeDebugLines(Vector3 center)
    {
        // (Debug line drawing logic remains the same)
        if (targetLights == null || _relativeSpherePoints.Count == 0) return;
        foreach (Light lightSource in targetLights)
        {
            if (lightSource == null || !lightSource.enabled || !lightSource.gameObject.activeInHierarchy) continue;
            if (lightSource.type == LightType.Point || lightSource.type == LightType.Spot)
            {
                float rangeSqr = lightSource.range * lightSource.range;
                if ((lightSource.transform.position - center).sqrMagnitude >= rangeSqr) continue;
            }
            Vector3 lightPos = lightSource.transform.position;
            Vector3 dirToLight = (lightSource.type == LightType.Directional) ? -lightSource.transform.forward : (lightPos - center);
            if (lightSource.type == LightType.Directional)
            {
                Debug.DrawLine(center, center + dirToLight.normalized * 2f, Color.yellow);
                continue;
            }
            Vector3 dirToLightNorm = dirToLight.normalized;
            foreach (Vector3 relPoint in _relativeSpherePoints)
            {
                Vector3 worldPoint = center + relPoint;
                if (Vector3.Dot(relPoint.normalized, dirToLightNorm) > VISIBILITY_DOT_THRESHOLD)
                {
                    bool isVisible = !Physics.Linecast(worldPoint, lightPos, obstructionLayers);
                    Debug.DrawLine(worldPoint, lightPos, isVisible ? Color.green : Color.red);
                }
            }
        }
    }

    void OnDrawGizmos()
    {
        // (Gizmo code remains the same)
        if (!visualizeSphere) return;
        EnsureSpherePointsGenerated();
        if (_relativeSpherePoints == null || _relativeSpherePoints.Count == 0) return;

        Vector3 center = GetDetectionCenter();
        if (center == Vector3.positiveInfinity) return;
        bool hasPoints = _relativeSpherePoints.Count > 0;
        Gizmos.color = hasPoints ? Color.cyan : Color.yellow;
        Gizmos.DrawWireSphere(center, detectionSphereRadius);
        if (hasPoints)
        {
            foreach (Vector3 relPoint in _relativeSpherePoints)
            {
                Gizmos.DrawSphere(center + relPoint, GIZMO_POINT_SIZE);
            }
        }
    }
}